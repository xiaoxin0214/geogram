<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Geogram: GEO::PCK Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Geogram
   &#160;<span id="projectnumber">Version 1.8.5-rc</span>
   </div>
   <div id="projectbrief">A programming library of geometric algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceGEO_1_1PCK.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GEO::PCK Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceGEO_1_1PCK.html" title="PCK (Predicate Construction Kit) implements a set of geometric predicates. PCK uses arithmetic filter...">PCK</a> (Predicate Construction Kit) implements a set of geometric predicates. <a class="el" href="namespaceGEO_1_1PCK.html" title="PCK (Predicate Construction Kit) implements a set of geometric predicates. PCK uses arithmetic filter...">PCK</a> uses arithmetic filters (Meyer and Pion), expansion arithmetics (Shewchuk) and simulation of simplicity (Edelsbrunner).  
<a href="namespaceGEO_1_1PCK.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a98bfa9f624ed630c8f6a1e17cedd683f"><td class="memItemLeft" align="right" valign="top"><a id="a98bfa9f624ed630c8f6a1e17cedd683f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a98bfa9f624ed630c8f6a1e17cedd683f">SOSMode</a> { <b>SOS_ADDRESS</b>
, <b>SOS_LEXICO</b>
 }</td></tr>
<tr class="memdesc:a98bfa9f624ed630c8f6a1e17cedd683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode for symbolic perturbations. <br /></td></tr>
<tr class="separator:a98bfa9f624ed630c8f6a1e17cedd683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac2871671e8516a6d52a48b6d77254efe"><td class="memTemplParams" colspan="2"><a id="ac2871671e8516a6d52a48b6d77254efe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac2871671e8516a6d52a48b6d77254efe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>same_point</b> (const <a class="el" href="classGEO_1_1vecng.html">vecng</a>&lt; 3, T &gt; &amp;v1, const <a class="el" href="classGEO_1_1vecng.html">vecng</a>&lt; 3, T &gt; &amp;v2)</td></tr>
<tr class="separator:ac2871671e8516a6d52a48b6d77254efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce47f0cda6fee4084d1ae68f2a315b"><td class="memTemplParams" colspan="2"><a id="ac9ce47f0cda6fee4084d1ae68f2a315b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac9ce47f0cda6fee4084d1ae68f2a315b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>same_point</b> (const <a class="el" href="classGEO_1_1vecng.html">vecng</a>&lt; 2, T &gt; &amp;v1, const <a class="el" href="classGEO_1_1vecng.html">vecng</a>&lt; 2, T &gt; &amp;v2)</td></tr>
<tr class="separator:ac9ce47f0cda6fee4084d1ae68f2a315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38b62b890290f4cee66e72df65c12af"><td class="memItemLeft" align="right" valign="top"><a id="ad38b62b890290f4cee66e72df65c12af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>same_point</b> (const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;v1, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;v2)</td></tr>
<tr class="separator:ad38b62b890290f4cee66e72df65c12af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d4fab4af390b3c225bf98d4786e06e"><td class="memItemLeft" align="right" valign="top"><a id="ab1d4fab4af390b3c225bf98d4786e06e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>same_point</b> (const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;v1, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;v2)</td></tr>
<tr class="separator:ab1d4fab4af390b3c225bf98d4786e06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ba8ce218957a755450083288fccb02"><td class="memItemLeft" align="right" valign="top"><a id="a75ba8ce218957a755450083288fccb02"></a>
<a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><b>orient_2d</b> (const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p0, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p1, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p2)</td></tr>
<tr class="separator:a75ba8ce218957a755450083288fccb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8655e8769dbaa9d2c7442dfe445507"><td class="memItemLeft" align="right" valign="top"><a id="a1e8655e8769dbaa9d2c7442dfe445507"></a>
<a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><b>orient_2d_projected</b> (const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p0, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p1, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p2, <a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a> axis)</td></tr>
<tr class="separator:a1e8655e8769dbaa9d2c7442dfe445507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26d70112ff966e7d8596b01bba307b4"><td class="memItemLeft" align="right" valign="top"><a id="ad26d70112ff966e7d8596b01bba307b4"></a>
<a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><b>orient_3d</b> (const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p0, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p1, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p2, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p3)</td></tr>
<tr class="separator:ad26d70112ff966e7d8596b01bba307b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf23befe9bb0263ccbb5b8743dc3c35f"><td class="memItemLeft" align="right" valign="top"><a id="abf23befe9bb0263ccbb5b8743dc3c35f"></a>
<a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dot_2d</b> (const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p0, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p1, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p2)</td></tr>
<tr class="separator:abf23befe9bb0263ccbb5b8743dc3c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f580fdf432600719d89d3d4e32b1461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a8f580fdf432600719d89d3d4e32b1461">orient_2dlifted_SOS</a> (const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p0, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p1, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p2, const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;p3, double h0, double h1, double h2, double h3)</td></tr>
<tr class="memdesc:a8f580fdf432600719d89d3d4e32b1461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3d orientation test with lifted points.  <a href="namespaceGEO_1_1PCK.html#a8f580fdf432600719d89d3d4e32b1461">More...</a><br /></td></tr>
<tr class="separator:a8f580fdf432600719d89d3d4e32b1461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779d1457420b4a3ec2e6f29637c82cc"><td class="memItemLeft" align="right" valign="top"><a id="a2779d1457420b4a3ec2e6f29637c82cc"></a>
<a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><b>orient_2dlifted_SOS_projected</b> (const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p0, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p1, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p2, const <a class="el" href="structGEO_1_1vec3HE.html">vec3HE</a> &amp;p3, double h0, double h1, double h2, double h3, <a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a> axis)</td></tr>
<tr class="separator:a2779d1457420b4a3ec2e6f29637c82cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb18293f42d442972a28618ba6a7714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#aeeb18293f42d442972a28618ba6a7714">set_SOS_mode</a> (<a class="el" href="namespaceGEO_1_1PCK.html#a98bfa9f624ed630c8f6a1e17cedd683f">SOSMode</a> m)</td></tr>
<tr class="memdesc:aeeb18293f42d442972a28618ba6a7714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current mode for handling symbolic perturbations (SOS for Simulation Of Simplicity).  <a href="namespaceGEO_1_1PCK.html#aeeb18293f42d442972a28618ba6a7714">More...</a><br /></td></tr>
<tr class="separator:aeeb18293f42d442972a28618ba6a7714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada327805a9a8b5c39ee9675c20b853c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO_1_1PCK.html#a98bfa9f624ed630c8f6a1e17cedd683f">SOSMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#ada327805a9a8b5c39ee9675c20b853c0">get_SOS_mode</a> ()</td></tr>
<tr class="memdesc:ada327805a9a8b5c39ee9675c20b853c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current mode for handling symbolic perturbations.  <a href="namespaceGEO_1_1PCK.html#ada327805a9a8b5c39ee9675c20b853c0">More...</a><br /></td></tr>
<tr class="separator:ada327805a9a8b5c39ee9675c20b853c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a3cba2f2d9ba0536b752896d252d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#abc3a3cba2f2d9ba0536b752896d252d2">side1_SOS</a> (const double *p0, const double *p1, const double *q0, <a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a> DIM)</td></tr>
<tr class="memdesc:abc3a3cba2f2d9ba0536b752896d252d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given directly) relative to a bisector.  <a href="namespaceGEO_1_1PCK.html#abc3a3cba2f2d9ba0536b752896d252d2">More...</a><br /></td></tr>
<tr class="separator:abc3a3cba2f2d9ba0536b752896d252d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed9aff9dd60112296fbc93e5e9c931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#aa4ed9aff9dd60112296fbc93e5e9c931">side2_SOS</a> (const double *p0, const double *p1, const double *p2, const double *q0, const double *q1, <a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a> DIM)</td></tr>
<tr class="memdesc:aa4ed9aff9dd60112296fbc93e5e9c931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given as the intersection between a segment and a bisector) relative to another bisector.  <a href="namespaceGEO_1_1PCK.html#aa4ed9aff9dd60112296fbc93e5e9c931">More...</a><br /></td></tr>
<tr class="separator:aa4ed9aff9dd60112296fbc93e5e9c931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e31026a00fe19170141d7fecb559ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a32e31026a00fe19170141d7fecb559ab">side3_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *q0, const double *q1, const double *q2, <a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a> DIM)</td></tr>
<tr class="memdesc:a32e31026a00fe19170141d7fecb559ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given as the intersection between a facet and two bisectors) relative to another bisector.  <a href="namespaceGEO_1_1PCK.html#a32e31026a00fe19170141d7fecb559ab">More...</a><br /></td></tr>
<tr class="separator:a32e31026a00fe19170141d7fecb559ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0e82dabd709a8a730e4fa1682a712b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#aaf0e82dabd709a8a730e4fa1682a712b">side3_3dlifted_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, double h0, double h1, double h2, double h3, const double *q0, const double *q1, const double *q2, bool SOS=true)</td></tr>
<tr class="memdesc:aaf0e82dabd709a8a730e4fa1682a712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given as the intersection between a facet and two bisectors) relative to another bisector.  <a href="namespaceGEO_1_1PCK.html#aaf0e82dabd709a8a730e4fa1682a712b">More...</a><br /></td></tr>
<tr class="separator:aaf0e82dabd709a8a730e4fa1682a712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e65c579fc7ee3ff66ea31b28e5f96a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a5e65c579fc7ee3ff66ea31b28e5f96a8">side4_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4, const double *q0, const double *q1, const double *q2, const double *q3, <a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a> DIM)</td></tr>
<tr class="memdesc:a5e65c579fc7ee3ff66ea31b28e5f96a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given as the intersection between a tetrahedron and three bisectors) relative to another bisector.  <a href="namespaceGEO_1_1PCK.html#a5e65c579fc7ee3ff66ea31b28e5f96a8">More...</a><br /></td></tr>
<tr class="separator:a5e65c579fc7ee3ff66ea31b28e5f96a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96617e4cfb52e1e70980d307123d888b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a96617e4cfb52e1e70980d307123d888b">side4_3d</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4)</td></tr>
<tr class="memdesc:a96617e4cfb52e1e70980d307123d888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given as the intersection between three bisectors) relative to another bisector.  <a href="namespaceGEO_1_1PCK.html#a96617e4cfb52e1e70980d307123d888b">More...</a><br /></td></tr>
<tr class="separator:a96617e4cfb52e1e70980d307123d888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae78f54e5682b1b132888733a058d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a3ae78f54e5682b1b132888733a058d2e">side4_3d_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4)</td></tr>
<tr class="memdesc:a3ae78f54e5682b1b132888733a058d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the side of a point (given as the intersection between three bisectors) relative to another bisector.  <a href="namespaceGEO_1_1PCK.html#a3ae78f54e5682b1b132888733a058d2e">More...</a><br /></td></tr>
<tr class="separator:a3ae78f54e5682b1b132888733a058d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e48727a7e73a6cf22db7773b5d50d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a5e48727a7e73a6cf22db7773b5d50d69">in_sphere_3d_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4)</td></tr>
<tr class="memdesc:a5e48727a7e73a6cf22db7773b5d50d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a 3d point is inside the circumscribed sphere of a 3d tetrahedron.  <a href="namespaceGEO_1_1PCK.html#a5e48727a7e73a6cf22db7773b5d50d69">More...</a><br /></td></tr>
<tr class="separator:a5e48727a7e73a6cf22db7773b5d50d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b0e0199df2438227743b9b05ded73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a3c4b0e0199df2438227743b9b05ded73">in_circle_2d_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3)</td></tr>
<tr class="memdesc:a3c4b0e0199df2438227743b9b05ded73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a 2d point is inside the circumscribed circle of a 3d triangle.  <a href="namespaceGEO_1_1PCK.html#a3c4b0e0199df2438227743b9b05ded73">More...</a><br /></td></tr>
<tr class="separator:a3c4b0e0199df2438227743b9b05ded73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5007ace86f6f1ac698e35397eaed91bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a5007ace86f6f1ac698e35397eaed91bc">in_circle_3d_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3)</td></tr>
<tr class="memdesc:a5007ace86f6f1ac698e35397eaed91bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a 3d point is inside the circumscribed circle of a 3d triangle.  <a href="namespaceGEO_1_1PCK.html#a5007ace86f6f1ac698e35397eaed91bc">More...</a><br /></td></tr>
<tr class="separator:a5007ace86f6f1ac698e35397eaed91bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f99358b78490f7dacddcf8601138e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a17f99358b78490f7dacddcf8601138e6">in_circle_3dlifted_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, double h0, double h1, double h2, double h3, bool SOS=true)</td></tr>
<tr class="memdesc:a17f99358b78490f7dacddcf8601138e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a lifted 3d point is inside the circumscribed circle of a lifted 3d triangle.  <a href="namespaceGEO_1_1PCK.html#a17f99358b78490f7dacddcf8601138e6">More...</a><br /></td></tr>
<tr class="separator:a17f99358b78490f7dacddcf8601138e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf4c85df02b31d71193ff71dabec591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#acbf4c85df02b31d71193ff71dabec591">orient_2d</a> (const double *p0, const double *p1, const double *p2)</td></tr>
<tr class="memdesc:acbf4c85df02b31d71193ff71dabec591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the orientation predicate in 3d.  <a href="namespaceGEO_1_1PCK.html#acbf4c85df02b31d71193ff71dabec591">More...</a><br /></td></tr>
<tr class="separator:acbf4c85df02b31d71193ff71dabec591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62455ae77ef22b0f6f4370048995297b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a62455ae77ef22b0f6f4370048995297b">orient_2d</a> (const <a class="el" href="namespaceGEO.html#ad7e1b53e52be6caed089a5f4f29d8057">vec2</a> &amp;p0, const <a class="el" href="namespaceGEO.html#ad7e1b53e52be6caed089a5f4f29d8057">vec2</a> &amp;p1, const <a class="el" href="namespaceGEO.html#ad7e1b53e52be6caed089a5f4f29d8057">vec2</a> &amp;p2)</td></tr>
<tr class="memdesc:a62455ae77ef22b0f6f4370048995297b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the orientation predicate in 2d.  <a href="namespaceGEO_1_1PCK.html#a62455ae77ef22b0f6f4370048995297b">More...</a><br /></td></tr>
<tr class="separator:a62455ae77ef22b0f6f4370048995297b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab7d63f5b3fa71f1b8eec2782078c3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a4ab7d63f5b3fa71f1b8eec2782078c3e">orient_2dlifted_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, double h0, double h1, double h2, double h3)</td></tr>
<tr class="memdesc:a4ab7d63f5b3fa71f1b8eec2782078c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3d orientation test with lifted points.  <a href="namespaceGEO_1_1PCK.html#a4ab7d63f5b3fa71f1b8eec2782078c3e">More...</a><br /></td></tr>
<tr class="separator:a4ab7d63f5b3fa71f1b8eec2782078c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4987ab128e464c5bbe715d163ee8d1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a4987ab128e464c5bbe715d163ee8d1fa">orient_3d</a> (const double *p0, const double *p1, const double *p2, const double *p3)</td></tr>
<tr class="memdesc:a4987ab128e464c5bbe715d163ee8d1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the orientation predicate in 3d.  <a href="namespaceGEO_1_1PCK.html#a4987ab128e464c5bbe715d163ee8d1fa">More...</a><br /></td></tr>
<tr class="separator:a4987ab128e464c5bbe715d163ee8d1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a019b246d623ab5c82bf91d2c82890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a16a019b246d623ab5c82bf91d2c82890">orient_3d</a> (const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p0, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p1, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p2, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p3)</td></tr>
<tr class="memdesc:a16a019b246d623ab5c82bf91d2c82890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the orientation predicate in 3d.  <a href="namespaceGEO_1_1PCK.html#a16a019b246d623ab5c82bf91d2c82890">More...</a><br /></td></tr>
<tr class="separator:a16a019b246d623ab5c82bf91d2c82890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a559edcc0c7b5714079ffda36de4e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a1a559edcc0c7b5714079ffda36de4e51">orient_3dlifted</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4, double h0, double h1, double h2, double h3, double h4)</td></tr>
<tr class="memdesc:a1a559edcc0c7b5714079ffda36de4e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 4d orientation test.  <a href="namespaceGEO_1_1PCK.html#a1a559edcc0c7b5714079ffda36de4e51">More...</a><br /></td></tr>
<tr class="separator:a1a559edcc0c7b5714079ffda36de4e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37767010717fca40fe0d8e933c8f6cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a37767010717fca40fe0d8e933c8f6cd6">orient_3dlifted_SOS</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4, double h0, double h1, double h2, double h3, double h4)</td></tr>
<tr class="memdesc:a37767010717fca40fe0d8e933c8f6cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 4d orientation test with symbolic perturbation.  <a href="namespaceGEO_1_1PCK.html#a37767010717fca40fe0d8e933c8f6cd6">More...</a><br /></td></tr>
<tr class="separator:a37767010717fca40fe0d8e933c8f6cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b37bc46df6d18fc1fdc9b08962d7a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a8b37bc46df6d18fc1fdc9b08962d7a4e">det_3d</a> (const double *p0, const double *p1, const double *p2)</td></tr>
<tr class="memdesc:a8b37bc46df6d18fc1fdc9b08962d7a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sign of the determinant of a 3x3 matrix formed by three 3d points.  <a href="namespaceGEO_1_1PCK.html#a8b37bc46df6d18fc1fdc9b08962d7a4e">More...</a><br /></td></tr>
<tr class="separator:a8b37bc46df6d18fc1fdc9b08962d7a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04afdab908d747674782a0fe0efd1f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a04afdab908d747674782a0fe0efd1f1e">det_4d</a> (const double *p0, const double *p1, const double *p2, const double *p3)</td></tr>
<tr class="memdesc:a04afdab908d747674782a0fe0efd1f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sign of the determinant of a 4x4 matrix formed by four 4d points.  <a href="namespaceGEO_1_1PCK.html#a04afdab908d747674782a0fe0efd1f1e">More...</a><br /></td></tr>
<tr class="separator:a04afdab908d747674782a0fe0efd1f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964b59d15bd98a91a71495dfb6d3fe7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a964b59d15bd98a91a71495dfb6d3fe7a">det_compare_4d</a> (const double *p0, const double *p1, const double *p2, const double *p3, const double *p4)</td></tr>
<tr class="memdesc:a964b59d15bd98a91a71495dfb6d3fe7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sign of the determinant of a 4x4 matrix formed by three 4d points and the difference of two 4d points.  <a href="namespaceGEO_1_1PCK.html#a964b59d15bd98a91a71495dfb6d3fe7a">More...</a><br /></td></tr>
<tr class="separator:a964b59d15bd98a91a71495dfb6d3fe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0913d1bc67a8836a57d10f511415ecea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a0913d1bc67a8836a57d10f511415ecea">aligned_3d</a> (const double *p0, const double *p1, const double *p2)</td></tr>
<tr class="memdesc:a0913d1bc67a8836a57d10f511415ecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether three points are aligned.  <a href="namespaceGEO_1_1PCK.html#a0913d1bc67a8836a57d10f511415ecea">More...</a><br /></td></tr>
<tr class="separator:a0913d1bc67a8836a57d10f511415ecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f2b2a5a5d629195f501061eb895b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a96f2b2a5a5d629195f501061eb895b40">dot_3d</a> (const double *p0, const double *p1, const double *p2)</td></tr>
<tr class="memdesc:a96f2b2a5a5d629195f501061eb895b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sign of the dot product between two vectors.  <a href="namespaceGEO_1_1PCK.html#a96f2b2a5a5d629195f501061eb895b40">More...</a><br /></td></tr>
<tr class="separator:a96f2b2a5a5d629195f501061eb895b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb25b673b06281da4167f0ba00533a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#afb25b673b06281da4167f0ba00533a4e">aligned_3d</a> (const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p0, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p1, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p2)</td></tr>
<tr class="memdesc:afb25b673b06281da4167f0ba00533a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether three points are aligned.  <a href="namespaceGEO_1_1PCK.html#afb25b673b06281da4167f0ba00533a4e">More...</a><br /></td></tr>
<tr class="separator:afb25b673b06281da4167f0ba00533a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe02dbb444c192d585feae0574fd78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a4fe02dbb444c192d585feae0574fd78f">dot_3d</a> (const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p0, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p1, const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;p2)</td></tr>
<tr class="memdesc:a4fe02dbb444c192d585feae0574fd78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sign of the dot product between two vectors.  <a href="namespaceGEO_1_1PCK.html#a4fe02dbb444c192d585feae0574fd78f">More...</a><br /></td></tr>
<tr class="separator:a4fe02dbb444c192d585feae0574fd78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b6d5aedac5fe4c49eafe4db94593b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a29b6d5aedac5fe4c49eafe4db94593b4">dot_compare_3d</a> (const double *v0, const double *v1, const double *v2)</td></tr>
<tr class="memdesc:a29b6d5aedac5fe4c49eafe4db94593b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two dot products.  <a href="namespaceGEO_1_1PCK.html#a29b6d5aedac5fe4c49eafe4db94593b4">More...</a><br /></td></tr>
<tr class="separator:a29b6d5aedac5fe4c49eafe4db94593b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55e6d0f26849919902beeebc05932f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#aa55e6d0f26849919902beeebc05932f1">points_are_identical_2d</a> (const double *p1, const double *p2)</td></tr>
<tr class="memdesc:aa55e6d0f26849919902beeebc05932f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two 2d points are identical.  <a href="namespaceGEO_1_1PCK.html#aa55e6d0f26849919902beeebc05932f1">More...</a><br /></td></tr>
<tr class="separator:aa55e6d0f26849919902beeebc05932f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980aa075bd4f5d11bc0acf3957364524"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a980aa075bd4f5d11bc0acf3957364524">points_are_identical_3d</a> (const double *p1, const double *p2)</td></tr>
<tr class="memdesc:a980aa075bd4f5d11bc0acf3957364524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two 3d points are identical.  <a href="namespaceGEO_1_1PCK.html#a980aa075bd4f5d11bc0acf3957364524">More...</a><br /></td></tr>
<tr class="separator:a980aa075bd4f5d11bc0acf3957364524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa266ca20fd47a6c862ce2d2e65007544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#aa266ca20fd47a6c862ce2d2e65007544">points_are_colinear_3d</a> (const double *p1, const double *p2, const double *p3)</td></tr>
<tr class="memdesc:aa266ca20fd47a6c862ce2d2e65007544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether three 3d points are colinear.  <a href="namespaceGEO_1_1PCK.html#aa266ca20fd47a6c862ce2d2e65007544">More...</a><br /></td></tr>
<tr class="separator:aa266ca20fd47a6c862ce2d2e65007544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f556e9908ee9d2cfccb95142766c83a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a4f556e9908ee9d2cfccb95142766c83a">orient_3d_inexact</a> (const double *p0, const double *p1, const double *p2, const double *p3)</td></tr>
<tr class="memdesc:a4f556e9908ee9d2cfccb95142766c83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the (approximate) orientation predicate in 3d.  <a href="namespaceGEO_1_1PCK.html#a4f556e9908ee9d2cfccb95142766c83a">More...</a><br /></td></tr>
<tr class="separator:a4f556e9908ee9d2cfccb95142766c83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680d07b96359db66c511517c158c6d68"><td class="memItemLeft" align="right" valign="top"><a id="a680d07b96359db66c511517c158c6d68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#a680d07b96359db66c511517c158c6d68">show_stats</a> ()</td></tr>
<tr class="memdesc:a680d07b96359db66c511517c158c6d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays some statistics about predicates, including the number of calls, the number of exact arithmetics calls, and the number of Simulation of Simplicity calls. <br /></td></tr>
<tr class="separator:a680d07b96359db66c511517c158c6d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceed096fe9b0185bb29f24e2506834f"><td class="memItemLeft" align="right" valign="top"><a id="abceed096fe9b0185bb29f24e2506834f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#abceed096fe9b0185bb29f24e2506834f">initialize</a> ()</td></tr>
<tr class="memdesc:abceed096fe9b0185bb29f24e2506834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needs to be called before using any predicate. <br /></td></tr>
<tr class="separator:abceed096fe9b0185bb29f24e2506834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac247bacbde1580c2e3d5659cbd66f3c1"><td class="memItemLeft" align="right" valign="top"><a id="ac247bacbde1580c2e3d5659cbd66f3c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGEO_1_1PCK.html#ac247bacbde1580c2e3d5659cbd66f3c1">terminate</a> ()</td></tr>
<tr class="memdesc:ac247bacbde1580c2e3d5659cbd66f3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needs to be called at the end of the program. <br /></td></tr>
<tr class="separator:ac247bacbde1580c2e3d5659cbd66f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespaceGEO_1_1PCK.html" title="PCK (Predicate Construction Kit) implements a set of geometric predicates. PCK uses arithmetic filter...">PCK</a> (Predicate Construction Kit) implements a set of geometric predicates. <a class="el" href="namespaceGEO_1_1PCK.html" title="PCK (Predicate Construction Kit) implements a set of geometric predicates. PCK uses arithmetic filter...">PCK</a> uses arithmetic filters (Meyer and Pion), expansion arithmetics (Shewchuk) and simulation of simplicity (Edelsbrunner). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0913d1bc67a8836a57d10f511415ecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0913d1bc67a8836a57d10f511415ecea">&#9670;&nbsp;</a></span>aligned_3d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GEO::PCK::aligned_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether three points are aligned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>the three points </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the three points are aligned. </td></tr>
    <tr><td class="paramname">false</td><td>otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>Function to be tested, use <a class="el" href="namespaceGEO_1_1PCK.html#aa266ca20fd47a6c862ce2d2e65007544" title="Tests whether three 3d points are colinear.">points_are_colinear_3d()</a> instead. </p>

</div>
</div>
<a id="afb25b673b06281da4167f0ba00533a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb25b673b06281da4167f0ba00533a4e">&#9670;&nbsp;</a></span>aligned_3d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GEO::PCK::aligned_3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether three points are aligned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>the three points </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the three points are aligned. </td></tr>
    <tr><td class="paramname">false</td><td>otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>Function to be tested, use <a class="el" href="namespaceGEO_1_1PCK.html#aa266ca20fd47a6c862ce2d2e65007544" title="Tests whether three 3d points are colinear.">points_are_colinear_3d()</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="predicates_8h_source.html#l00612">612</a> of file <a class="el" href="predicates_8h_source.html">predicates.h</a>.</p>

</div>
</div>
<a id="a8b37bc46df6d18fc1fdc9b08962d7a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b37bc46df6d18fc1fdc9b08962d7a4e">&#9670;&nbsp;</a></span>det_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::det_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sign of the determinant of a 3x3 matrix formed by three 3d points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>the three points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the determinant of the matrix. </dd></dl>

</div>
</div>
<a id="a04afdab908d747674782a0fe0efd1f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04afdab908d747674782a0fe0efd1f1e">&#9670;&nbsp;</a></span>det_4d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::det_4d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sign of the determinant of a 4x4 matrix formed by four 4d points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3</td><td>the four points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the determinant of the matrix. </dd></dl>

</div>
</div>
<a id="a964b59d15bd98a91a71495dfb6d3fe7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964b59d15bd98a91a71495dfb6d3fe7a">&#9670;&nbsp;</a></span>det_compare_4d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::det_compare_4d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sign of the determinant of a 4x4 matrix formed by three 4d points and the difference of two 4d points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3,p4</td><td>the four points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the determinant of the matrix p0 p1 p2 p4-p3 </dd></dl>

</div>
</div>
<a id="a96f2b2a5a5d629195f501061eb895b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f2b2a5a5d629195f501061eb895b40">&#9670;&nbsp;</a></span>dot_3d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::dot_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sign of the dot product between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>three 3d points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the dot product between the vectors p0p1 and p0p2. </dd></dl>

</div>
</div>
<a id="a4fe02dbb444c192d585feae0574fd78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe02dbb444c192d585feae0574fd78f">&#9670;&nbsp;</a></span>dot_3d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::dot_3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sign of the dot product between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>three 3d points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the dot product between the vectors p0p1 and p0p2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="predicates_8h_source.html#l00625">625</a> of file <a class="el" href="predicates_8h_source.html">predicates.h</a>.</p>

</div>
</div>
<a id="a29b6d5aedac5fe4c49eafe4db94593b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b6d5aedac5fe4c49eafe4db94593b4">&#9670;&nbsp;</a></span>dot_compare_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::dot_compare_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two dot products. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0,v1,v2</td><td>three vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of v0.v1 - v0.v2 </dd></dl>

</div>
</div>
<a id="ada327805a9a8b5c39ee9675c20b853c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada327805a9a8b5c39ee9675c20b853c0">&#9670;&nbsp;</a></span>get_SOS_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO_1_1PCK.html#a98bfa9f624ed630c8f6a1e17cedd683f">SOSMode</a> GEO::PCK::get_SOS_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current mode for handling symbolic perturbations. </p>
<dl class="section return"><dt>Returns</dt><dd>one of SOS_ADDRESS, SOS_LEXICO </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceGEO_1_1PCK.html#aeeb18293f42d442972a28618ba6a7714" title="Sets the current mode for handling symbolic perturbations (SOS for Simulation Of Simplicity).">set_SOS_mode()</a> </dd></dl>

</div>
</div>
<a id="a3c4b0e0199df2438227743b9b05ded73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b0e0199df2438227743b9b05ded73">&#9670;&nbsp;</a></span>in_circle_2d_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::in_circle_2d_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a 2d point is inside the circumscribed circle of a 3d triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>vertices of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>the point to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>whenever <code>p3</code> is inside the circumscribed circle of the triangle <code>p0</code>, <code>p1</code>, <code>p2</code> </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>whenever <code>p2</code> is outside the circumscribed circle of the triangle <code>p0</code>, <code>p1</code>, <code>p2</code> </td></tr>
    <tr><td class="paramname">perturb()</td><td>if <code>p3</code> is exactly on the circumscribed circle of the triangle <code>p0</code>, <code>p1</code>, <code>p2</code>, where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>p3</code> belongs to the plane yielded by <code>p0</code>, <code>p1</code> and <code>p2</code> </dd></dl>

</div>
</div>
<a id="a5007ace86f6f1ac698e35397eaed91bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5007ace86f6f1ac698e35397eaed91bc">&#9670;&nbsp;</a></span>in_circle_3d_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::in_circle_3d_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a 3d point is inside the circumscribed circle of a 3d triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>vertices of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>the point to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>whenever <code>p3</code> is inside the circumscribed circle of the triangle <code>p0</code>, <code>p1</code>, <code>p2</code> </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>whenever <code>p2</code> is outside the circumscribed circle of the triangle <code>p0</code>, <code>p1</code>, <code>p2</code> </td></tr>
    <tr><td class="paramname">perturb()</td><td>if <code>p3</code> is exactly on the circumscribed circle of the triangle <code>p0</code>, <code>p1</code>, <code>p2</code>, where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>p3</code> belongs to the plane yielded by <code>p0</code>, <code>p1</code> and <code>p2</code> </dd></dl>

</div>
</div>
<a id="a17f99358b78490f7dacddcf8601138e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f99358b78490f7dacddcf8601138e6">&#9670;&nbsp;</a></span>in_circle_3dlifted_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::in_circle_3dlifted_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>SOS</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a lifted 3d point is inside the circumscribed circle of a lifted 3d triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>vertices of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>the point to be tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h0,h1,h2</td><td>lifted coordinate of the triangle vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h3</td><td>lifted coordinate of the point to be tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SOS</td><td>if true, do the symbolic perturbation in the degenerate cases </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>whenever (<code>p3</code>, <code>h3</code>) is inside the circumscribed circle of the triangle (<code>p0</code>,<code>h0</code>) (<code>p1</code>,<code>h1</code>), (<code>p2</code>, <code>h2</code>) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>whenever (<code>p3</code>, <code>h3</code>) is outside the circumscribed circle of the triangle (<code>p0</code>,<code>h0</code>) (<code>p1</code>,<code>h1</code>), (<code>p2</code>, <code>h2</code>) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if (<code>p3</code>, <code>h3</code>) is exactly on the circumscribed circle of the triangle (<code>p0</code>,<code>h0</code>) (<code>p1</code>,<code>h1</code>), (<code>p2</code>, <code>h2</code>) where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>(<code>p3</code>, <code>h3</code>) belongs to the hyperplane yielded by (<code>p0</code>, <code>h0</code>), (<code>p1</code>, <code>h1</code>) and (<code>p2</code>, <code>h2</code>) </dd></dl>

</div>
</div>
<a id="a5e48727a7e73a6cf22db7773b5d50d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e48727a7e73a6cf22db7773b5d50d69">&#9670;&nbsp;</a></span>in_sphere_3d_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::in_sphere_3d_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a 3d point is inside the circumscribed sphere of a 3d tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>third vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>fourth vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p4</td><td>the point to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>whenever <code>p4</code> is inside the circumscribed sphere of the tetrahedron <code>p0</code>, <code>p1</code>, <code>p2</code>, <code>p3</code> </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>whenever <code>p4</code> is outside the circumscribed sphere of the tetrahedron <code>p0</code>, <code>p1</code>, <code>p2</code>, <code>p3</code> </td></tr>
    <tr><td class="paramname">perturb()</td><td>if <code>p4</code> is exactly on the circumscribed sphere of the tetrahedron <code>p0</code>, <code>p1</code>, <code>p2</code>, <code>p3</code>, where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>orient_3d(p0,p1,p2,p3) &gt; 0 </dd></dl>

</div>
</div>
<a id="acbf4c85df02b31d71193ff71dabec591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf4c85df02b31d71193ff71dabec591">&#9670;&nbsp;</a></span>orient_2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_2d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the orientation predicate in 3d. </p>
<p>Computes the sign of the signed area of the triangle p0, p1, p2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>vertices of the triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if the triangle is oriented positively </td></tr>
    <tr><td class="paramname">ZERO</td><td>if the triangle is flat </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if the triangle is oriented negatively </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>check whether orientation is inverted as compared to Shewchuk's version. </dd></dl>

</div>
</div>
<a id="a62455ae77ef22b0f6f4370048995297b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62455ae77ef22b0f6f4370048995297b">&#9670;&nbsp;</a></span>orient_2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_2d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#ad7e1b53e52be6caed089a5f4f29d8057">vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#ad7e1b53e52be6caed089a5f4f29d8057">vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#ad7e1b53e52be6caed089a5f4f29d8057">vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the orientation predicate in 2d. </p>
<p>Computes the sign of the signed area of the triangle p0, p1, p2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2</td><td>vertices of the triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if the triangle is oriented positively </td></tr>
    <tr><td class="paramname">ZERO</td><td>if the triangle is flat </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if the triangle is oriented negatively </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>check whether orientation is inverted as compared to Shewchuk's version. </dd></dl>

<p class="definition">Definition at line <a class="el" href="predicates_8h_source.html#l00425">425</a> of file <a class="el" href="predicates_8h_source.html">predicates.h</a>.</p>

</div>
</div>
<a id="a4ab7d63f5b3fa71f1b8eec2782078c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab7d63f5b3fa71f1b8eec2782078c3e">&#9670;&nbsp;</a></span>orient_2dlifted_SOS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_2dlifted_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 3d orientation test with lifted points. </p>
<p>Given three lifted points p0', p1', p2' in R^2, tests if the lifted point p3' in R^3 lies below or above the plane passing through the three points p0', p1', p2'. The first two coordinates and the third one are specified in separate arguments for each vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3</td><td>first 2 coordinates of the vertices of the 3-simplex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h0,h1,h2,h3</td><td>heights of the vertices of the 3-simplex </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if p3' lies below the plane </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if p3' lies above the plane </td></tr>
    <tr><td class="paramname">perturb()</td><td>if p3' lies exactly on the hyperplane where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f580fdf432600719d89d3d4e32b1461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f580fdf432600719d89d3d4e32b1461">&#9670;&nbsp;</a></span>orient_2dlifted_SOS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_2dlifted_SOS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGEO_1_1vec2HE.html">vec2HE</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 3d orientation test with lifted points. </p>
<p>Given three lifted points p0', p1', p2' in R^2, tests if the lifted point p3' in R^3 lies below or above the plane passing through the three points p0', p1', p2'. The first two coordinates and the third one are specified in separate arguments for each vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3</td><td>first 2 coordinates of the vertices of the 3-simplex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h0,h1,h2,h3</td><td>heights of the vertices of the 3-simplex </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if p3' lies below the plane </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if p3' lies above the plane </td></tr>
    <tr><td class="paramname">perturb()</td><td>if p3' lies exactly on the hyperplane where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4987ab128e464c5bbe715d163ee8d1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4987ab128e464c5bbe715d163ee8d1fa">&#9670;&nbsp;</a></span>orient_3d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the orientation predicate in 3d. </p>
<p>Computes the sign of the signed volume of the tetrahedron p0, p1, p2, p3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3</td><td>vertices of the tetrahedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if the tetrahedron is oriented positively </td></tr>
    <tr><td class="paramname">ZERO</td><td>if the tetrahedron is flat </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if the tetrahedron is oriented negatively </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>check whether orientation is inverted as compared to Shewchuk's version. </dd></dl>

</div>
</div>
<a id="a16a019b246d623ab5c82bf91d2c82890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a019b246d623ab5c82bf91d2c82890">&#9670;&nbsp;</a></span>orient_3d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGEO.html#a6044ad0fa5784ccde33b7bb3fa0e1459">vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the orientation predicate in 3d. </p>
<p>Computes the sign of the signed volume of the tetrahedron p0, p1, p2, p3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3</td><td>vertices of the tetrahedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if the tetrahedron is oriented positively </td></tr>
    <tr><td class="paramname">ZERO</td><td>if the tetrahedron is flat </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if the tetrahedron is oriented negatively </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>check whether orientation is inverted as compared to Shewchuk's version. </dd></dl>

<p class="definition">Definition at line <a class="el" href="predicates_8h_source.html#l00486">486</a> of file <a class="el" href="predicates_8h_source.html">predicates.h</a>.</p>

</div>
</div>
<a id="a4f556e9908ee9d2cfccb95142766c83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f556e9908ee9d2cfccb95142766c83a">&#9670;&nbsp;</a></span>orient_3d_inexact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_3d_inexact </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the (approximate) orientation predicate in 3d. </p>
<p>Computes the sign of the (approximate) signed volume of the tetrahedron p0, p1, p2, p3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>third vertex of the tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>fourth vertex of the tetrahedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if the tetrahedron is oriented positively </td></tr>
    <tr><td class="paramname">ZERO</td><td>if the tetrahedron is flat </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if the tetrahedron is oriented negatively </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>check whether orientation is inverted as compared to Shewchuk's version. </dd></dl>

<p class="definition">Definition at line <a class="el" href="predicates_8h_source.html#l00695">695</a> of file <a class="el" href="predicates_8h_source.html">predicates.h</a>.</p>

</div>
</div>
<a id="a1a559edcc0c7b5714079ffda36de4e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a559edcc0c7b5714079ffda36de4e51">&#9670;&nbsp;</a></span>orient_3dlifted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_3dlifted </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 4d orientation test. </p>
<p>Given four lifted points p0', p1', p2', and p3' in R^4, tests if the lifted point p4' in R^4 lies below or above the hyperplance passing through the four points p0', p1', p2', and p3'. This version does not apply symbolic perturbation. The first three coordinates and the fourth one are specified in separate arguments for each vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3,p4</td><td>first 3 coordinates of the vertices of the 4-simplex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h0,h1,h2,h3,h4</td><td>heights of the vertices of the 4-simplex </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if p4' lies below the hyperplane </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if p4' lies above the hyperplane </td></tr>
    <tr><td class="paramname">ZERO</td><td>if p4' lies exactly on the hyperplane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37767010717fca40fe0d8e933c8f6cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37767010717fca40fe0d8e933c8f6cd6">&#9670;&nbsp;</a></span>orient_3dlifted_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::orient_3dlifted_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 4d orientation test with symbolic perturbation. </p>
<p>Given four lifted points p0', p1', p2', and p3' in R^4, tests if the lifted point p4' in R^4 lies below or above the hyperplance passing through the four points p0', p1', p2', and p3'. Symbolic perturbation is applied whenever the 5 vertices are not linearly independent. The first three coordinates and the fourth one are specified in separate arguments for each vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1,p2,p3,p4</td><td>first 3 coordinates of the vertices of the 4-simplex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h0,h1,h2,h3,h4</td><td>heights of the vertices of the 4-simplex </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if p4' lies below the hyperplane </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if p4' lies above the hyperplane </td></tr>
    <tr><td class="paramname">perturb()</td><td>if p4' lies exactly on the hyperplane where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa266ca20fd47a6c862ce2d2e65007544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa266ca20fd47a6c862ce2d2e65007544">&#9670;&nbsp;</a></span>points_are_colinear_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GEO::PCK::points_are_colinear_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether three 3d points are colinear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>third point </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if <code>p1</code>, <code>p2</code> and <code>p3</code> are colinear \retbal false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa55e6d0f26849919902beeebc05932f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55e6d0f26849919902beeebc05932f1">&#9670;&nbsp;</a></span>points_are_identical_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GEO::PCK::points_are_identical_2d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether two 2d points are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if <code>p1</code> and <code>p2</code> have exactly the same coordinates </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a980aa075bd4f5d11bc0acf3957364524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980aa075bd4f5d11bc0acf3957364524">&#9670;&nbsp;</a></span>points_are_identical_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GEO::PCK::points_are_identical_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether two 3d points are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if <code>p1</code> and <code>p2</code> have exactly the same coordinates </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeb18293f42d442972a28618ba6a7714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb18293f42d442972a28618ba6a7714">&#9670;&nbsp;</a></span>set_SOS_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GEO::PCK::set_SOS_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGEO_1_1PCK.html#a98bfa9f624ed630c8f6a1e17cedd683f">SOSMode</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current mode for handling symbolic perturbations (SOS for Simulation Of Simplicity). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>one of SOS_ADDRESS, SOS_LEXICO</td></tr>
  </table>
  </dd>
</dl>
<p>If SOS_ADDRESS mode is used, then points are supposed to be allocated in a fixed array, and the same point always designated by the same address. If SOS_LEXICO is used then points are sorted in lexicographic order for computing the symbolic perturbation. SOS_LEXICO works for points that are generated dynamically (with no fixed address). </p>

</div>
</div>
<a id="abc3a3cba2f2d9ba0536b752896d252d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3a3cba2f2d9ba0536b752896d252d2">&#9670;&nbsp;</a></span>side1_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side1_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a>&#160;</td>
          <td class="paramname"><em>DIM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given directly) relative to a bisector. </p>
<p>Computes the side of \( q0 \) relative to \( \Pi(p0,p1) \). Symbolic perturbation is applied whenever equality holds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0,p1</td><td>extremities of the bisector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q0</td><td>point to be tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIM</td><td>number of coordinates of the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0,q0) &lt; d(p1,q0) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0,q0) &gt; d(p1,q1) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if f(p0,q0) = d(p1,q1), where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only some specific dimensions are implemented (3,4,6 and 7) </dd></dl>

</div>
</div>
<a id="aa4ed9aff9dd60112296fbc93e5e9c931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ed9aff9dd60112296fbc93e5e9c931">&#9670;&nbsp;</a></span>side2_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side2_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a>&#160;</td>
          <td class="paramname"><em>DIM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given as the intersection between a segment and a bisector) relative to another bisector. </p>
<p>Computes the side of \( q = \Pi(p0,p1) \cap [q0,q1] \) relative to \( \Pi(p0,p2) \). Symbolic perturbation is applied whenever equality holds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first extremity of the bisectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second extremity of the first bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second extremity of the second bisector (against which orientation is tested) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q0,q1</td><td>extremities of the segment (that defines the intersection q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0,q) &lt; d(p2,q) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0,q) &gt; d(p2,q) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if d(p0,q) = d(p2,q), where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only some specific dimensions are implemented (3,4,6 and 7) </dd></dl>

</div>
</div>
<a id="aaf0e82dabd709a8a730e4fa1682a712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0e82dabd709a8a730e4fa1682a712b">&#9670;&nbsp;</a></span>side3_3dlifted_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side3_3dlifted_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>SOS</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given as the intersection between a facet and two bisectors) relative to another bisector. </p>
<p>Computes the side of \( q = \Pi(p0 h0,p1 h1) \cap Pi(p0 h0,p2 h2) \cap \Delta[q0, q1, q2] \) relative to \( \Pi(p0 hp0,p3 hp3) \). Symbolic perturbation is applied whenever equality holds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first extremity of the bisectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second extremity of the first bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second extremity of the second bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>second extremity of the third bisector (against which orientation is tested) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">h0,h1,h2,h3</td><td>lifted coordinates of <code>p0</code>, <code>p1</code>, <code>p2</code> and <code>p3</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q0,q1,q2</td><td>vertices of the triangle (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SOS</td><td>if true, do the symbolic perturbation in the degenerate case </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0 hp0,q) &lt; d(p3 hp3, q) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0 hp0,q) &gt; d(p3 hp3, q) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if d(p0 hp0,q) = d(p3 hp3, q), where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32e31026a00fe19170141d7fecb559ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e31026a00fe19170141d7fecb559ab">&#9670;&nbsp;</a></span>side3_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side3_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a>&#160;</td>
          <td class="paramname"><em>DIM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given as the intersection between a facet and two bisectors) relative to another bisector. </p>
<p>Computes the side of \( q = \Pi(p0,p1) \cap Pi(p0,p2) \cap \Delta[q0,q1,q2] \) relative to \( \Pi(p0,p3) \). Symbolic perturbation is applied whenever equality holds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first extremity of the bisectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second extremity of the first bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second extremity of the second bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>second extremity of the third bisector (against which orientation is tested) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q0,q1,q2</td><td>vertices of the triangle (that defines the intersection q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0,q) &lt; d(p3,q) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0,q) &gt; d(p3,q) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if d(p0,q) = d(p3,q), where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only some specific dimensions are implemented (3,4,6 and 7) </dd></dl>

</div>
</div>
<a id="a96617e4cfb52e1e70980d307123d888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96617e4cfb52e1e70980d307123d888b">&#9670;&nbsp;</a></span>side4_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side4_3d </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given as the intersection between three bisectors) relative to another bisector. </p>
<p>Computes the side of \( q = \Pi(p0,p1) \cap \Pi(p0,p2) \cap \Pi(p0,p3) \) relative to \( Pi(p0,p4) \). This version does not apply symbolic perturbation when equality holds. <a class="el" href="namespaceGEO_1_1PCK.html#a96617e4cfb52e1e70980d307123d888b" title="Computes the side of a point (given as the intersection between three bisectors) relative to another ...">side4_3d()</a> is a special case of side4(), where the ambient and intrinsic dimensions coincide (therefore no embedding tetrahedron is needed). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first extremity of the bisectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second extremity of the first bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second extremity of the second bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>second extremity of the third bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p4</td><td>second extremity of the fourth bisector (against which orientation is tested) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0,q) &lt; d(p4,q) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0,q) &gt; d(p4,q) </td></tr>
    <tr><td class="paramname">ZERO</td><td>if d(p0,q) = d(p4,q), </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ae78f54e5682b1b132888733a058d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae78f54e5682b1b132888733a058d2e">&#9670;&nbsp;</a></span>side4_3d_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side4_3d_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given as the intersection between three bisectors) relative to another bisector. </p>
<p>Computes the side of \( q = \Pi(p0,p1) \cap \Pi(p0,p2) \cap \Pi(p0,p3) \) relative to \( Pi(p0,p4) \). Symbolic perturbation is applied whenever equality holds. <a class="el" href="namespaceGEO_1_1PCK.html#a96617e4cfb52e1e70980d307123d888b" title="Computes the side of a point (given as the intersection between three bisectors) relative to another ...">side4_3d()</a> is a special case of side4(), where the ambient and intrinsic dimensions coincide (therefore no embedding tetrahedron is needed). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first extremity of the bisectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second extremity of the first bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second extremity of the second bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>second extremity of the third bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p4</td><td>second extremity of the fourth bisector (against which orientation is tested) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0,q) &lt; d(p4,q) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0,q) &gt; d(p4,q) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if d(p0,q) = d(p4,q), where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e65c579fc7ee3ff66ea31b28e5f96a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e65c579fc7ee3ff66ea31b28e5f96a8">&#9670;&nbsp;</a></span>side4_SOS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGEO.html#a9c97e58e4526cb2ab931b3fde0a3b002">Sign</a> GEO::PCK::side4_SOS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>q3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceGEO.html#ae771f961036ac7f98502ff145b99d424">coord_index_t</a>&#160;</td>
          <td class="paramname"><em>DIM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the side of a point (given as the intersection between a tetrahedron and three bisectors) relative to another bisector. </p>
<p>Computes the side of \( q = \Pi(p0,p1) \cap Pi(p0,p2) \cap Pi(p0,p3) \cap \Delta[q0,q1,q2,q3] \) relative to \( \Pi(p0,p4) \). Symbolic perturbation is applied whenever equality holds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>first extremity of the bisectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>second extremity of the first bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second extremity of the second bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>second extremity of the third bisector (that defines the intersection q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p4</td><td>second extremity of the fourth bisector (against which orientation is tested) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q0,q1,q2,q3</td><td>vertices of the tetrahedron (that defines the intersection q) (that defines the intersection q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">POSITIVE</td><td>if d(p0,q) &lt; d(p4,q) </td></tr>
    <tr><td class="paramname">NEGATIVE</td><td>if d(p0,q) &gt; d(p4,q) </td></tr>
    <tr><td class="paramname">perturb()</td><td>if d(p0,q) = d(p4,q), where <code>perturb()</code> denotes a globally consistent perturbation, that returns either POSITIVE or NEGATIVE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only some specific dimensions are implemented (3,4,6 and 7) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceGEO.html">GEO</a></li><li class="navelem"><a class="el" href="namespaceGEO_1_1PCK.html">PCK</a></li>
    <li class="footer">Generated on Mon Jul 24 2023 08:41:09 for Geogram by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
